{"meta":{"title":"波客","subtitle":null,"description":"陈波的个人博客","author":"陈波","url":"https://cba023.github.io","root":"/"},"pages":[{"title":"关于","date":"2023-08-08T11:36:05.812Z","updated":"2023-08-08T11:36:05.812Z","comments":false,"path":"about/index.html","permalink":"https://cba023.github.io/about/index.html","excerpt":"","text":"我的邮箱：&#99;&#x62;&#97;&#48;&#50;&#x33;&#64;&#x68;&#111;&#116;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#99;&#111;&#x6d;"},{"title":"分类","date":"2020-04-12T05:27:24.000Z","updated":"2023-08-08T11:36:05.812Z","comments":false,"path":"categories/index.html","permalink":"https://cba023.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-04-12T05:32:07.000Z","updated":"2023-08-08T11:36:05.813Z","comments":false,"path":"tags/index.html","permalink":"https://cba023.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"解决hexo-abbrlink与hexo-asset-image冲突导致博文图片不显示的问题","slug":"解决hexo-abbrlink与hexo-asset-image冲突","date":"2023-08-03T08:58:27.000Z","updated":"2023-08-08T11:36:05.810Z","comments":true,"path":"posts/7ee94710/","link":"","permalink":"https://cba023.github.io/posts/7ee94710/","excerpt":"","text":"转载自：abbrlink插件导致图片失效 - 故人随笔 (imgod.me) abbrlink 导致图片无法显示 在 hexo 里我们引入图片都是用 hexo-asset-image 插件，但单独使用是没有问题的，如果遇到标题包含中文的情况下我们复制文章链接会变成一堆很长的编码，这时候我们就要用到 abbrlink 插件，至于插件如何使用我就不多赘述了，看文档即可当我们配置完成后，就会发现虽然文章链接确实没有问题了，但是图片却无法显示 我们打开 f12 查看会发现图片路径变成 /.io//001.webp 而实际路径应该是 posts/:abbrlink/001.webp 解决方案(一) 适用于 permalink: posts/:abbrlink/方案 打开blog\\node_modules\\hexo-asset-image\\index.js文件 将其中第 24 行代码var endPos = link.lastIndexOf(&#39;.&#39;);更改为var endPos = link.length-1; 重新Git Bash Here 123hexo cleanhexo ghexo d 解决方案(二) 适用于 permalink: posts/:abbrlink.html方案 打开blog\\node_modules\\hexo-asset-image\\index.js文件 将其中第 24 行代码var endPos = link.lastIndexOf(&#39;.&#39;);更改为var endPos = link.length-5; 重新Git Bash Here 123hexo cleanhexo ghexo d","categories":[],"tags":[]},{"title":"TableBuilder - 更方便快捷构建TableView页面","slug":"TableBuilder","date":"2023-08-03T01:32:32.000Z","updated":"2023-08-08T11:36:05.660Z","comments":true,"path":"posts/4e3de635/","link":"","permalink":"https://cba023.github.io/posts/4e3de635/","excerpt":"","text":"简介更方便快捷构建TableView页面 优点: 更少代码 声明式 灵活度高 基于 UITableViewDelegate &amp; UITableViewDataSource 已经处理好Cell复用 方便重写和扩展 示例要运行示例项目，请克隆仓库，并首先从示例目录运行pod install。 要求 Swift 5+ 安装TableBuilder可以通过CocoaPods获得。安装只需将下面这行添加到你的Podfile中: 1pod &#x27;TableBuilder&#x27; 使用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990import TableBuilderclass ViewController: UIViewController &#123; @IBOutlet weak var tableView: UITableView! var tableProxy: TableProxy! override func viewDidLoad() &#123; super.viewDidLoad() reloadTable() &#125; var show: Bool = true func reloadTable() &#123; // 绑定构造器 tableProxy = tableView.bd.build(TableBuilder &#123; for _ in 0..&lt;3 &#123; // 创建TableViewSection TableSectionBuilder &#123; // 创建TableViewRow TableRowBuilder( cellHeight: 50, cellType: TableViewCell1.self, reuseType: .nib) &#123; tableView, indexPath, cell in &#125; didSelectRowAtIndexPath: &#123; tableView, indexPath, cell in print(&quot;CellType1的单独的点击事件&quot;) &#125; TableRowBuilder( cellHeight: 50, cellType: TableViewCell2.self, reuseType: .anyClass) &#123; tableView, indexPath, cell in cell.contentView.backgroundColor = .green cell.textLabel?.text = &quot;\\(indexPath.row)&quot; &#125; didSelectRowAtIndexPath: &#123; tableView, indexPath, cell in print(&quot;=====Cell类型2的单独的点击事件&quot;) &#125; let count = 10 for _ in 0..&lt;count &#123; TableRowBuilder( cellHeight: 30, autoCellHeight: false, cellType: UITableViewCell.self, reuseType: .anyClass) &#123; tableView, indexPath, cell in // cell定制 cell.contentView.backgroundColor = .blue cell.textLabel?.text = &quot;\\(indexPath.row)&quot; &#125; &#125; if show &#123; TableRowBuilder( cellHeight: 50, cellType: UITableViewCell.self) &#123; tableView, indexPath, cell in cell.contentView.backgroundColor = .purple cell.textLabel?.text = &quot;\\(indexPath.row)&quot; &#125; TableRowBuilder( cellHeight: 50, cellType: UITableViewCell.self) &#123; tableView, indexPath, cell in cell.contentView.backgroundColor = .purple cell.textLabel?.text = &quot;\\(indexPath.row)&quot; &#125; &#125; else &#123; TableRowBuilder( cellHeight: 90, cellType: UITableViewCell.self) &#123; tableView, indexPath, cell in cell.contentView.backgroundColor = .yellow cell.textLabel?.text = &quot;\\(indexPath.row)&quot; &#125; &#125; &#125; &#125; &#125;) /// 全局选中 tableProxy.didSelectRowAtIndexPath = &#123; tableView, indexPath in print(&quot;clicked: \\(indexPath.section) - \\(indexPath.row)&quot;) &#125; tableView.reloadData() &#125; &#125; 开源许可TableBuilder在MIT许可下可用。查看许可证文件以获取更多信息。","categories":[],"tags":[]},{"title":"iOS模块化开发的两种基本实现方式","slug":"iOS模块化开发的实现","date":"2022-03-02T10:25:05.000Z","updated":"2023-08-08T11:36:05.661Z","comments":true,"path":"posts/8f33a448/","link":"","permalink":"https://cba023.github.io/posts/8f33a448/","excerpt":"","text":"前言模块化开发有诸多的优势： 避免耦合 分工明细 职责单一 依赖清晰 便于移植 灵活组合 … 模块化开发试用场景： 项目较大，功能复杂 功能模块需要跨项目运行 功能模块有高频度复用需求 … iOS开发中模块化主流的有两种方案： CocoaPods私有库 一个XCode Workspace组合若干个Project 综合前两中方案实现 使用CocoaPods私有库实现模块化这里也可以参考我的另一篇文章，如何创建CocoaPods开源库，里面有CocoaPods创建自建仓库的详细说明。 接下来我们实战创建两个私有库来实现模块化开发。 得到一个工程，工程目录如下: 创建Cocoapods私有库显然，这时候CocoaPods还没有参与管理项目，我们找到项目根目录。 我们要使用Cocoapods在这里创建一个新的库命名为MyUILib用做UI工具库，执行： 1pod lib create MyUILib 在输入一系列的参数后，控制台输出如下： 编辑私有库的工程接着XCode会自动打开一个新生成的工程。打开ReplaceMe.Swift所在目录. 可以看到MyUILib下包含了Classes和Assets两个目录将Classes拖入工程ReplaceMe所在的位置。点击Finish完成目录导入。 删除Classes目录下的所有文件和ReplaceMe.swift 点击Move to Trash即删除到废纸篓。接着在Classes目录下创建创建一个文件，命名为UIView+Extensions.swift 然后我们在UIView+Extensions.swift文件中写入代码： 12345678import UIKitextension UIView &#123; /// 设置背景色为红色 public func setRedBackgroundColor() &#123; self.backgroundColor = .red &#125;&#125; 接下来我们就可以去之前我们创建的Proj1中引入MyUILib模块（实际上是Cocoapods私有库）了。 关联工程与私有库模块关闭MyUILib工程，使用终端打开Proj1工程目录。 1cd /Users/xxx/.../Proj1/ ，然后执行： 1pod init Proj1变成了使用Cocoapods管理的工程。工程目录下多了一个Podfile文件，使用文本编辑器打开该文件，加入如下代码： 1pod &#x27;MyUILib&#x27;, :path =&gt; &#x27;./MyUILib/&#x27; 执行pod install 主工程Proj1成功依赖MyUILib库。如果要创建更多的模块，可以重复上述的步骤，实现更多的私有库模块。 我们来看看工程调用效果。打开Proj1.xcworkspace。在ViewController中调用MyUILib中的API，可以看到实际效果。 大功告成。 WorkSpace嵌套Project实现模块化初始化主工程创建一个工程命名为Proj2作为我们开发的主工程。 接着创建一个WorkSpace，同样命名为Proj2(也可以叫其他名字)。 创建WorkSpace并将主工程引入其中将新创建的WorkSpace放在与Proj2.xcodeproj相同路径。 点击Save。 接着XCode会自动打开该WorkSpace。我们在菜单中找到Add Files to &quot;Proj2&quot;。 选择Proj2.xcodeproj，点击Add，即实现添加Project到WorkSpace。 创建一个工程作为依赖模块并引入到WorkSpace然后我们再创建一个XCode工程。 我们创建一个用作UI库的模块，命名为UILib，这里创建类型选择Framework。 将该工程的保存路径放在与Proj2.xcodeproj相同路径。 点击Create之后，即生成了一个工程，关闭该工程窗口。 接着在之前打开的WorkSpace中将UILib工程添加进去。步骤之前已经有讲，这次选中UILib.xcodeproj工程。 点击Add后，WorkSpace中就包含UILib和Proj2两个工程了，其中Proj2这里作为主工程，UILib则是主工程依赖的模块。要注意的是模块之前的依赖管理一定要理清，尽量使用单向依赖，方便模块解耦，也符合设计模式的依赖倒置法则。 在模块中添加API并在主工程中调用接下来我们在UILib中添加一个UIView+Extensions.swift文件，添加一段代码。 12345678import UIKitextension UIView &#123; /// 设置背景色为红色 public func setRedBackgroundColor() &#123; self.backgroundColor = .red &#125;&#125; 在Proj2的Build Phases -&gt; Link Binary With Libraries中引入UILib.framework。 接下来在Proj1的ViewController中调用UILib中的方法，即实现了设置红色背景色的API。","categories":[],"tags":[]},{"title":"如何创建CocoaPods开源库","slug":"如何创建CocoaPods开源库","date":"2022-01-27T16:00:00.000Z","updated":"2023-08-08T11:36:05.762Z","comments":true,"path":"posts/b4fe90af/","link":"","permalink":"https://cba023.github.io/posts/b4fe90af/","excerpt":"","text":"创建与配置创建Pods库现在我们来建立一个基于Swift语言的Pods库。命名为SwiftUIKitExtensions，用途是UIKit的扩展功能库。 1pod lib create SwiftUIKitExtensions 执行指令后依次键盘录入需要的配置。 执行后会生成一个名为SwiftUIKitExtensions的XCode工程并且由XCode自动打开。 配置podspec文件找到工程根目录下的SwiftUIKitExtensions.podspec文件。更改描述信息s.summary和s.description,默认版本0.1.0；更改源文件路径为 s.source_files = &#39;SwiftUIKitExtensions/Classes/*&#39;。 创建GitHub仓库 关联仓库GitHub目前已经不提倡使用HTTPS协议Push代码了，所以关联仓库地址尽量使用SSH方式。 123git remote add origin git@github.com:cba023/SwiftUIKitExtensions.gitgit branch -M maingit push -u origin main 执行指令后仓库中就存在创建的库的文件了。 添加源文件接下来我们就可以添加我们想要添加的源文件了。首先删除ReplaceMe文件；然后找到Classes目录(右键Show in Finder)，然后将Classes目录导入到工程中，如下图： 对Pods库进行编辑然后编辑UIView+Extensions.Swift内容如下： 1234567891011import UIKitextension UIView &#123; @discardableResult public func _backgroundColor(_ backgroundColor: UIColor) -&gt; Self &#123; self.backgroundColor = backgroundColor return self &#125; &#125; 验证API调用添加该API用于设定UIView及其子类实例的背景色并返回该实例。然后我们来测试下API是否能正常调用。 显然的API已经能调用了，我们运行下App看看效果。根据代码的意思，App首页背景色变成浅灰色。如下： 现在，我们的Pods已经是一个完整的Pods私有库了。那么如何发布到CocoaPods让它成为一个可供开源社区使用的Pods公有库呢，下一节详细介绍。 上传为Pods公有库接下来上传我们自己创建的Pods库到CocoaPods。向 CocoaPods 注册账户信息。 注册账户信息1pod trunk register &lt;邮箱&gt; &#x27;&lt;用户名&gt;&#x27; --description=&#x27;&lt;描述&gt;&#x27; 然后邮箱会收到一封邮件。打开并点击，会提示： 验证个人账户然后我们检查下我们的个人信息。 1pod trunk me 同步Git Tag能清晰地看到自己的用户信息。那么接下来就可以上传我们的开源库了。将我们本次修改后的源码push到GitHub, 给当前节点打上Tag, 保持与版本号相同，即0.1.0。 1git tag -a 0.1.0 -m &quot;v0.1.0&quot; 推送标签： 1git push origin 0.1.0 验证并上传公有库 验证 1pod spec lint SwiftUIKitExtensions.podspec --allow-warnings --verbose 验证成功 如果验证失败，控制台有响应错误提示，这时候请稍有耐心地检查并修复问题。 最后一步，推送仓库到CocoaPods。 1pod trunk push SwiftUIKitExtensions.podspec --allow-warnings --verbose 执行上述命令后，执行推送仓库，推送成功后我们可以在控制台看到： 已经成功了。自制的SwiftUIKitExtensions变成CocoaPods公有库。上传后一段时间（索引库更新后）我们就可以搜索到该库了。","categories":[],"tags":[]},{"title":"一气呵成，完全自建iOS内测分发平台","slug":"一气呵成，完全自建iOS内测分发平台","date":"2021-09-12T06:46:00.000Z","updated":"2023-08-08T11:36:05.710Z","comments":true,"path":"posts/5b8e9f57/","link":"","permalink":"https://cba023.github.io/posts/5b8e9f57/","excerpt":"","text":"需要什么 XCode编译环境：用于编译iOS应用程序 openssl环境（用于生成自签SSL证书） HTML分发网页（本文附相应文件链接，可以直接下载部署） nginx环境：用于配置http和https服务 Jenkins 用于持续集成（远程构建） 可用于分发的iOS证书签名（如：adhoc签名，appstore签名） 本地git环境和远程git仓库（用于代码托管和持续集成代码拉取） 创建App使用XCode创建一个iOS应用工程，命名App1。这里我们以Swift语言创建该工程。我们将要对项目配置三个运行环境（Objective-C配置环境变量有稍许差异），分别如下： 名称 环境 DEV 开发环境 UAT 预发布环境 PROD 生产环境 接下来使用CocoaPods对工程进行管理。打开终端，进入到工程目录，执行pod init和pod install。如下图: 为了让应用在分发时可以构建多个渠道的安装包，这里我们可以对它的环境进行参数化配置。打开工程的xcworkspace文件，现在我们要对工程配置2个Scheme，创建完成后加上原有的Scheme总计3个。 创建好的Sheme列表如下： 在原有的两个Build configuration基础上再创建4个，分别让Debug和 Release对应DEV和UAT环境。 为了让App变得完整接下来配置项目的图标信息。 接下来关联Sheme和Build Configuraion（Debug和Release两种情况）。 对应关系如表所示： Scheme Debug Release App1 Debug Release App1_DEV Debug_DEV Release_DEV App1_UAT Debug_UAT Release_UAT 效果如下： 接着在项目工程中配置环境变量，如图所示： Build configuration 环境变量 Debug DEBUG Debug_DEV DEBUG ENVIOMENT_DEV Debug_UAT DEBUG ENVIOMENT_UAT Release Release_DEV ENVIOMENT_DEV Debug ENVIOMENT_UAT 然后就可以在代码中加入环境变量判断来控制源码编译实现不同环境的App的差异配置。 这里我们在不同环境下分别让App首页背景为不同颜色 环境 首页背景色 DEV 红 UAT 绿 PROD 蓝 首页使用环境变量来控制预编译。源码如下： 12345678910#if ENVIROMENT_DEVview.backgroundColor = .redenviromentLabel.text = &quot;DEV&quot;#elseif ENVIROMENT_UATview.backgroundColor = .greenenviromentLabel.text = &quot;UAT&quot;#elseview.backgroundColor = .blueenviromentLabel.text = &quot;PROD&quot;#endif 例如：将Sheme选择为App_UAT，编译运行，即可看到设备上运行的App首页被金色变成了绿色，说明环境变量关联Scheme已经生效。 页面展示效果： 显然，通过选择不同的Sheme来关联环境变量还可以做更多的操作，比如网络接口地址等。 工程仓库已经上传到GitHub，可以下载参考。 仓库地址：https://github.com/cba023/App1.git 使用XCode自带的Archive工具分发App更改应用的版本相关信息 选着指定的Scheme执行归档，注意设备要选择Any iOS Device。 备份ExportOptions.plist到iOS_Distribution，重命名为ExportOptions_adhoc.plist 分发应用时涉及到证书配置、签名、和分发途径的相关信息，先使用Archive工具通过adhoc途径分发一次adhoc，获取ExportOptions.plist文件并备份。此处不细说，若有不熟之处，可上互联网搜索相关资料。 导入分发网页将之前已经编写好的Web网页导入指定目录，这里我们指定/Users/chenbo/DAPP为Web服务根目录。Web网页的文件结构如下: 12345678910/Users/chenbo/DAPP ├── detail.html├── index.html└── source ├── qrcode.min.js ├── reset.css ├── style.css └── vue.global.prod.js1 directory, 6 files 分发网页Git仓库地址：https://github.com/cba023/iOS_DistributionAssets.git 生成自签SSL证书首先获取本机IP地址方便项目的配置与部署。Mac上查看IP地址非常简单，可在系统偏好设置-&gt;网络中可以查看。 创建公私钥文件夹 12mkdir -p /usr/local/etc/ssl/privatemkdir -p /usr/local/etc/ssl/certs 创建秘钥和证书 1234sudo openssl req \\ -x509 -nodes -days 365 -newkey rsa:2048 \\ -keyout /usr/local/etc/ssl/private/self-signed.key \\ -out /usr/local/etc/ssl/certs/self-signed.crt 输入指定后需要填写证书的一些信息，Common Name需要填写为自定义的域名，这里我把它设成了本机的IP地址。 然后打开/usr/local/etc/ssl目录，private和certs文件夹分别生成了私钥和证书。 /Users/chenbo/DAPP目录下创建一个ssl子目录，再把self-signed.crt拷贝一份到ssl中，用于分发网页中的SSL证书下载。 安装和使用nginx安装nginx安装nginx有多种方式，这里我们使用brew来安装，如果你的Mac上没有安装brew环境，可以去网上了解下brew的安装教程。 执行以下指令，brew会自动安装nginx： 1brew install nginx 安装完成后在终端输入： 1nginx -version 如果显示了nginx版本即表示已经安装成功。 配置nginx的http和https服务由于苹果官方要求分发应用必须使用https协议，而我们自己搭建服务使用了自签证书，需要先使用http服务下载证书后才能正常使用https服务，所以这里我们同时配置http和https服务。 使用访达打开/usr/local/etc/nginx目录，编辑nginx.conf文件。如下： 123456789101112131415161718192021server &#123; listen 80; listen 443 ssl; server_name localhost; # ssl on; # location of ssl certificate ssl_certificate /usr/local/etc/ssl/certs/self-signed.crt; # location of ssl key ssl_certificate_key /usr/local/etc/ssl/private/self-signed.key; ssl_session_cache shared:SSL:1m; ssl_session_timeout 5m; ssl_ciphers HIGH:!aNULL:!MD5; ssl_prefer_server_ciphers on; location / &#123; root /Users/chenbo/DAPP; index index.html index.htm; &#125; &#125; 上述配置开启了80和443端口，即开启了http和https服务， ssl_certificate和ssl_certificate_key分别对应的自签名证书和私钥的路径，和openssl生成的路径保持一致。这里有一点要注意，/Users/chenbo/DAPP是我设定的nginx服务根目录，该目录和上一小节中的HTML存放路径保持一致。 接下来就可以启动nginx服务了。 1brew services start nginx 如下图所示，nginx成功启动。 打开Mac的系统偏好设置-&gt;安全与隐私-&gt;防火墙-&gt;关闭，即关闭Mac的防火墙。 接着在浏览器中打开我们之前设定的服务地址。 http://192.168.0.103 配置iOS应用分发Shell脚本 Shell脚本下载地址：https://github.com/cba023/iOS_DistributionAssets.git 把iOS_Distribution目录拷贝到用户文件夹。 123456789/Users/chenbo/iOS_Distribution├── AutoSh│ ├── ExportOptions_adhoc.plist│ └── distribute.sh└── Others ├── base.plist └── blank.plist2 directories, 4 files ExportOptions_adhoc.plist是之前使用XCode打包时生成的ExportOptions.plist重命名而来，包含了项目的构建信息。 distribute.sh文件需做稍许更改 __APP_NAME=&quot;APP1&quot; # 应用的名称这里固定 __HOST=&quot;192.168.0.103&quot; # Host指定为nginx服务的IP地址 Other目录下有两个plist文件，后面在脚本运行时能调用到，请不要自行修改文件内容 blank.plist: 空属性列表文件，用于脚本执行写入分发记录信息 base.plist: 用于写入App远程安装时的远程配置信息 检查完善DAPP目录的文件与配置DAPP即/Users/chenbo/DAPP目录，从上文已经得知在DAPP中已经包含了下列文件： 分发网页相关文件 ssl证书文件 在DAPP中创建images目录，并导入应用分发时要用到的两个尺寸的Logo文件，格式png。 文件名 分辨率 image_57x57.png 57 * 57 image_512x512.png 512 * 512 导入后DAPP目录内容如下： 现在就可以通过脚本来构建分发应用了。 使用Shell直接构建App并分发把iOS_Distribution目录下的AutoSh目录拷贝到App1的工程根目录，然后使用终端打开工程根目录下的AutoSh，执行： 1sh distribute.sh -h 可以看到： 终端显示了脚本的使用方法，这里我们执行下列指令： 1sh distribute.sh -b Release -s App1 -u &quot;修复问题若干；优化性能若干；增加功能若干；XXX xx,XXX_XX&quot; 执行，如下图所示，终端窗口自动将更更新内容显示出来了，并展示了更多的日志信息。 直到构建完成。 此时我们打开分发的网页地址，发现历史版本中多了一项记录，即刚才构建的项目。 尝试更改App1工程内的版本信息，再次执行分发指令，并尝试更改工程的Scheme为App1_DEV或App1： 分发DEV环境的包 1sh distribute.sh -b Release_DEV -s App1_DEV -u &quot;版本改 为1.0.1；&quot; 分发UAT环境的包 1sh distribute.sh -b Release_UAT -s App1_UAT -u &quot;UAT；&quot; 分发的网页地址多了两条记录，而且筛选菜单也有了多种选项可以筛选版本号和构建类型。 我们点击一条记录。 即跳转到了单次分发的详情页，该页面真实了APP1本次构建的详细信息，包括构建的一些参数和更新内容。如果手机和构建的Mac主机是处于一个局域网内且Mac主机关机了防火墙，则可以实现扫码安装该应用包（保证当前签名已经录入了安装手机的UDID情况方能使用）。 手机扫码后Safari浏览器打开分发详情页，首次安装App前需要点击页面左下角的安装SSL证书（描述文件），并去手机设置-&gt;通用-&gt;关于本机中信任该描述文件，然再点击点击安装字样按钮。 然后就自动安装到手机上了。 使用Jenkins来管理应用分发 Jenkins安装教程：https://gitee.com/jenkins-zh 或 https://www.jenkins.io 。Jenkins安装好后需要配置环境变量才能保证可以调用Shell中的指令，可进入Jenkins系统管理-&gt;系统配置-&gt;全局属性-&gt;环境变量中配置PATH，PATH内容可以从Mac终端中输入echo $PATH打印的内容拷贝过来。 Jenkins中配置的Shell，可以实现Jenkins参数化运行。 12345678910111213141516171819202122#!/bin/bashexport LANG=&quot;en_US.UTF-8&quot;if [[ $&#123;SCHEME&#125; == &quot;App1_DEV&quot; ]]; then __BUILD_CONF=&quot;Release_DEV&quot;elif [[ $&#123;SCHEME&#125; == &quot;App1_UAT&quot; ]]; then __BUILD_CONF=&quot;Release_UAT&quot;else __BUILD_CONF=&quot;Release&quot;fi__UPDATES=$&#123;UPDATES&#125;echo &quot;__UPDATES:$&#123;__UPDATES&#125;&quot;__UPDATES_LENGTH=$&#123;#__UPDATES&#125;if [[ $&#123;__UPDATES_LENGTH&#125; -lt 1 ]]; then __UPDATES=$(git log --format=%B -n 1 HEAD)fiecho &quot;Jenkins -&gt; SCHEME: $&#123;SCHEME&#125;, __BUILD_CONF: $&#123;__BUILD_CONF&#125;&quot;cp -rf /Users/`whoami`/iOS_Distribution/AutoSh/ $&#123;WORKSPACE&#125;/AutoSh/cd $&#123;WORKSPACE&#125;/AutoSh/sh $&#123;WORKSPACE&#125;/AutoSh/distribute.sh -a $&#123;DOWNLOAD_HOST&#125; -s $&#123;SCHEME&#125; -b $&#123;__BUILD_CONF&#125; -u &quot;$&#123;__UPDATES&#125;&quot; 点击保存。 参数化构建。 设定构建的参数。 开始构建后可以看到构建进度。 可从构建任务重选择查看控制台输出的日志。 日志显示任务完成。 构建成功，然后进入分发网页，即看到分发记录里又多了一条记录。接着就可以使用逸动设备扫码安装应用了。","categories":[],"tags":[]},{"title":"UITableViewAgent：一个闭包搞定UITableView的代理实现","slug":"UITableViewAgent","date":"2021-09-02T13:20:46.000Z","updated":"2023-08-08T11:36:05.660Z","comments":true,"path":"posts/b72a2539/","link":"","permalink":"https://cba023.github.io/posts/b72a2539/","excerpt":"","text":"https://github.com/cba023/UITableViewAgent.git 示例程序要运行示例项目，克隆仓库，并首先从Example目录运行’ pod install ‘。 安装与使用UITableViewAgent可以通过CocoaPods获得。安装在你的Podfile中添加以下代码: 1pod &#x27;UITableViewAgent&#x27; 运行条件：iOS 9.0+ (Swift 5+) UITableViewAgent可以承担UITableViewDataSource和UITableDelegate的指责，让TableView的编码变得更加容易和充满乐趣。为什么要使用UITableViewAgent呢？请看下文。 使用UITableViewDataSource和UITableViewDelegate实现TableView数据呈现让我们来看看传统的TableView编码： 设置tableView的代理 12tableView.dataSource = selftableView.delegate = self 代理回调 1234567891011121314151617181920212223242526272829303132333435363738func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123; if section == 0 &#123; return self.news.newslist?.count ?? 0 &#125; else if section == 1 &#123; return 1 &#125; else &#123; return 10 &#125;&#125;func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -&gt; CGFloat &#123; if indexPath.section == 0 &#123; return UITableView.automaticDimension &#125; else if indexPath.section == 1 &#123; return 80.0 &#125; else &#123; return 100.0 &#125;&#125;func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123; if indexPath.section == 0 &#123; let cell = tableView.dequeueReusableCell(withIdentifier: &quot;NewsListTableViewCell&quot;, for: IndexPath) as! NewsListTableViewCell cell.lblTitle.text = self.news.newslist![indexPath.row].title cell.lblSubTitle.text = self.news.newslist![indexPath.row].source return cell &#125; else if indexPath.section == 1 &#123; let cell = tableView.dequeueReusableCell(withIdentifier: &quot;AppliancesTableViewCell&quot;, for: IndexPath) as! AppliancesTableViewCell.self cell.lblName.text = self.appliances!.name cell.lblColor.text = self.appliances!.color cell.lblPrice.text = &quot;\\(self.appliances!.price)&quot; return cell &#125; else &#123; let cell = tableView.dequeueReusableCell(withIdentifier: &quot;PersonTCell.self&quot;, for: IndexPath) as! PersonTCell cell.lblName.text = &quot;人物 - \\(indexPath.row)&quot; return cell &#125;&#125; 嗯…这里实现了一个多类型Cell和多种数据的TableView列表展示，这里没有列举出Header与Footer的复用，也没有列出Cell选中某行时的回调。类似这样的代码实现有诸多的缺点： 代码量大：实现简单的功能需要大量代码，影响开发效率。 灵活性差：配置数据和UI不够灵活，多个类的复用视图的处理需要繁琐判断，开发者需要自行计算索引值已经行数等不必要的数据。 可阅读性差：为了遵守TableView的代理函数，形式上写入大量代码，却没有直观地凸显出数据和UI。 使用UITableViewAgent实现TableView数据呈现定制Cell数据行12345678910111213tableViewAgent = UITableViewAgent(tableView: tableView, display: UITableViewDisplay(&#123; sections in sections.append(UITableViewSectionDisplay(&#123; rows in for i in 0..&lt;10 &#123; rows.append(UITableViewRowDisplay(cellHeight: 60, cellType: UITableViewCell.self, reuseType: .anyClass) &#123; tableView, indexPath, cell in cell.textLabel?.text = &quot;row: _ \\(i)&quot; &#125; didSelectRowAtIndexPath: &#123;[weak self] tableView, indexPath, cell in guard let self = self else &#123; return &#125; let vc = TraditionalListViewController() self.navigationController?.pushViewController(vc, animated: true) &#125;) &#125; &#125;))&#125;)) 只需要这里少许的代码即可实现10行行高为50.0像素点,类型为UITableViewCell的Cell，选中某一行时，通过其中didSelectRowAtIndexPath回调方法实现响应的操作。当然，功能远远不只这么简单，若需要比较复杂的需求，它的优势将体现得更加明显。 比如： Cell行数免计算灵活配置 各行Cell高度灵活配置 各行Cell类型与复用形式灵活配置 各行Cell的数据展示灵活配置 各行Cell点击响应事件的灵活配置 123456789101112131415161718192021222324252627// 添加一行Cell展示动物信息rows.append(UITableViewRowDisplay(cellHeight: 100, cellType: PersonTCell.self, reuseType: .nib) &#123; tableView, indexPath, cell in cell.name.text = &quot;Panda&quot; cell.country.text = &quot;China&quot;&#125; didSelectRowAtIndexPath: &#123; tableView, indexPath, cell in // 选中动物Cell后回调 tableView.deselectRow(at: indexPath, animated: true) print(&quot;Animal is selected:&quot;, tableView, indexPath, cell)&#125;)// 添加若干行Cell展示人物信息for (i, person) in persons.enumerated() &#123; rows.append(UITableViewRowDisplay(cellHeight: 60, cellType: PersonCell.self, reuseType: .anyClass) &#123; tableView, indexPath, cell in cell.numberLabel.text = &quot;Number is: \\(i)&quot; cell.nameLabel.text = person.name cell.genderLabel.text = person.gender &#125;&#125;// 添加电器Cell展示电视信息rows.append(UITableViewRowDisplay(cellHeight: 120, cellType: AppliancesTableViewCell.self, reuseType: .nib) &#123; tableView, indexPath, cell in cell.lblName.text = &quot;TV&quot;&#125; didSelectRowAtIndexPath: &#123; tableView, indexPath, cell in// 选中电器Cell后回调 tableView.deselectRow(at: indexPath, animated: true) print(&quot;This is a TV&quot;)&#125;) 定制数据组下列是展示一个新闻相关的组： 1234567891011// 增加新闻section, header高度45，不允许自动行高(自动行高需要Cell的约束支持，即内容决定Cell高度)，header复用形式为XIB，类型为NewsListTableHeaderViewsections.append(UITableViewSectionDisplay(headerHeight: 45.0, isAutoHeaderHeight: false, headerReuse:.nib(NewsListTableHeaderView.self, &#123; tabelView, section, header in// 给header设置标题 header.lblName.text = &quot;News Header&quot;&#125;), &#123; rows in // row.append(XXX) // row.append(XXX)&#125;, footerHeight: 50.0, isAutoFooterHeight: false, footerReuse: .anyClass(NewsListTableFooterView.self, &#123; tableView, section, footer in// footer高度50，不允许自动行高，header复用形式为anyClass，类型为NewsListTableFooterView,设置文本标签展示内容 footer.lblDesc.text = &quot;News Footer&quot;&#125;))) header和footer的复用参数（headerHeight和footerReuse）可以设定类型如下： .anyClass: 纯代码型视图，继承自UIView。 .nib: XIB型视图，继承自UITableHeaderFooterView。 .none: 不设定Header或Footer。 作者Chen Bo（陈波）, &#x63;&#x62;&#x61;&#x30;&#50;&#51;&#x40;&#x68;&#x6f;&#x74;&#109;&#97;&#x69;&#108;&#x2e;&#x63;&#x6f;&#109; 证书UITableViewAgent在MIT许可下可用。查看许可文件以获得更多信息。","categories":[],"tags":[]},{"title":"TableViewReuse，一句话搞定TableViewCell、Header或Footer的复用","slug":"TableViewReuse","date":"2021-06-07T15:20:46.000Z","updated":"2023-08-08T11:36:05.660Z","comments":true,"path":"posts/939d9a6c/","link":"","permalink":"https://cba023.github.io/posts/939d9a6c/","excerpt":"","text":"https://github.com/cba023/TableViewReuse 优点 TableViewCell、TableViewHeader和TableViewFooter的复用比传统的方式更简单 免去了TableViewCell的注册 同时支持Objective-C和Swift语言 示例要运行示例项目，在工程的Podfile中引入TableViewReuse，运行’ pod install ‘。 安装TableViewReuse可以通过CocoaPods获得。安装在你的Podfile中添加以下代码: 1pod &#x27;TableViewReuse&#x27; 使用我们可以直接在Swift中使用它，我在Objective-C中 import &lt;TableViewReuse-umbrella.h&gt;来使用它 Swift场景复用 Nib 类型 TableViewCell传统风格: 1234// Register celltableView.register(UINib(nibName: &quot;NibListTableViewCell&quot;, bundle: nil), forCellReuseIdentifier: &quot;NibListTableViewCell&quot;)// Dequeue reusable cellstableView.dequeueReusableCell(withIdentifier: &quot;NibListTableViewCell&quot;, for: indexPath) 可以看到，传统的重用tableViewCell方法很麻烦。 现在: 我们有更简便的方式来实现它。 1234// Call the Swift API for Nib type TableViewCelllet cell = tableView.dequeueReusableCell(nibClass: NibListTableViewCell.self)// Call the Objective-C API for Nib type TableViewCelllet cell = tableView.dequeueReusableCell(withNibClass: NibListTableViewCell.self) as! NibListTableViewCell 重用手写代码类型的TableViewCell传统风格: 1234// Register celltableView.register(AnyClassTableViewCell.self, forCellReuseIdentifier: &quot;AnyClassTableViewCell&quot;)// Dequeue reusable cellstableView.dequeueReusableCell(withIdentifier: &quot;AnyClassTableViewCell&quot;, for: indexPath) 现在: 1234// Call the Swift API for Any class TableViewCelllet cell = tableView.dequeueReusableCell(anyClass: AnyClassTableViewCell.self)// Call the Objective-C API for Any class TableViewCelllet cell = tableView.dequeueReusableCell(withAnyClass: AnyClassTableViewCell.self) as! AnyClassTableViewCell Objective-场景复用 Nib 类型 TableViewCell传统风格: 1234// Register cell[tableView registerNib:[UINib nibWithNibName:@&quot;NibListTableViewCell&quot; bundle:nil] forCellReuseIdentifier:@&quot;NibListTableViewCell&quot;];// Dequeue reusable cellsNibListTableViewCell *cell = tableView.dequeueReusableCell(withIdentifier: &quot;NibListTableViewCell&quot;, for: indexPath) 现在: 1NibListTableViewCell *cell = [tableView dequeueReusableCellWithNibClass:NibListTableViewCell.class]; 重用手写代码类型的TableViewCell传统风格: 1234// Register cell[tableView registerClass:AnyClassTableViewCell.class forCellReuseIdentifier:@&quot;AnyClassTableViewCell&quot;];// Dequeue reusable cellsAnyClassTableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@&quot;AnyClassTableViewCell&quot; forIndexPath:indexPath]; 现在: 1AnyClassTableViewCell *cell = [tableView dequeueReusableCellWithAnyClass:AnyClassTableViewCell.class];","categories":[],"tags":[]},{"title":"使用Hexo搭建个人博客网站 \n","slug":"使用Hexo搭建个人博客网站","date":"2020-04-12T07:40:37.000Z","updated":"2023-08-08T11:36:05.746Z","comments":true,"path":"posts/8953dfef/","link":"","permalink":"https://cba023.github.io/posts/8953dfef/","excerpt":"","text":"该案例是在Mac OS环境下实现，其他平台可以借鉴但不能完全照搬。 Hexo官网：https://hexo.io/zh-cn/ Hexo官方配置文档: https://hexo.io/docs/configuration hiker主题GitHub地址（包含文档）：https://github.com/iTimeTraveler/hexo-theme-hiker.git themes/hiker 要说了解Hexo,还得从简书开始，简书作为国内知名的创作社区，竟然在使用百度搜索时会在自己的链接下方有一个”个人博客搭建“的入口，如下： 一丝好奇让我随性的打开了这个链接,进入后，我立马见到了一句充满诱惑力的标题：“5分钟 搭建免费个人博客”，我简直是捡到了宝。简单看了下，好像不难，由此我开始一步一步的实现免费建站。 登入GitHub因为我是GitHub的用户，我直接进入创建资源库，这里我填写的cba023.github.io, cba023是我的用户名，这里要和GitHub的账户名保持一致，后面访问的博客地址也是这一个。 以public方式创建，这样能保证上传后，博客能够在公网访问到，点击Create respository完成创建资源库。 Hexo环境搭建Mac环境下搭建非常简单，使用Homebrew安装Node.js。接下来就是打开终端，开始噼里啪啦。 安装nvm 1234brew install nvmmkdir ~/.nvmexport NVM_DIR=~/.nvm.$(brew --prefix nvm)/nvm.sh 安装完成，重启终端。输入： 1nvm install latest 保持网络通畅，等待片刻，Hexo依赖的环境就装好了。接下来就是主角Hexo登场。 1sudo npm install hexo-cli -g 需要输入用户密码。稍等片刻，安装完成。安装过程可能有一些偶然的错误，会在控制台返回错误信息，然后我们可以把错误信息复制到网络上检索就会有相关的解决方案。 博客建站生成工作文件夹首先需要在用户文件夹建立博客工作区文件夹，我选择的是~/Documents路径 打开指定的文件夹 1cd ~/Documents 初始化hexo工作文件目录，文件夹名和GitHub中创建的资源库文件目录一致，我创建的是hexo init cba023.github.io 1hexo init &lt;username&gt;.github.io 在Documents文件夹下多了一个&lt;username&gt;.github.io目录，后面我们统称为工作文件夹，里面有一些文件，其中有一个_config.yml文件夹，这是Hexo的配置文件。我们主要的配置是在这里完成的，后面再做讲解。 让博客站跑起来使用终端进入到刚才生成的工作文件夹&lt;username&gt;.github.io目录 1cd &lt;username&gt;.github.io 接着输入： 1hexo s 终端会打印很多信息，最后还会显示一个链接地址。这个时候我们的博客就可以在本地计算机打开了，我们在浏览器中输入本地服务链接http://localhost:4000，可以看到： 如果看到了Hello World, 说明本地服务已经跑起来了。接下来我们只需要配置里面的参数，就可以让这个服务为我们所用。 开始使用设置主题Hexo默认配置了一个主题landscape。我去官方的主题库里找到了hiker主题并换成了它，主题可以用git从GitHub克隆。新开一个终端窗口，定位到工作文件夹下。键入： 1git clone https://github.com/iTimeTraveler/hexo-theme-hiker.git themes/hiker 这样hiker主题就被克隆下来了。这时候我们进入工作文件夹下的_config.yml,把主题配置从theme: landscape改成： 1theme: hiker 这样主题就成功设置成hiker了，这时候重启Hexo服务（开启服务的终端窗口键入ctrl + c，也可以关闭之前运行本地服务的终端窗口，新开一个终端窗口）： 1hexo s 再打开localhost:4000地址，发现网页画风变了。 这样，主题更换就算完成了，该网页可以滚动，往上面滚动网页可以看到更多的内容。 设置标签 这是hiker主题的首页向上滚动后的界面，默认包含5个标签：Home, Archives, Categories, Tags, About。现在还是英文的标题，打开工作文件夹下的_config.yml，修改如下部分内容： 123456title: 陈波·博客subtitle: description: &#x27;&#x27;keywords: author: 陈波language: zh-CN 这里我们除了更改语言环境，顺便把博客拥有人的信息填写下，然后重启Hexo服务，刷新浏览器中本地服务链接的网页，网页变成中文了，而且博主的名字成了自己的名字。Hexo博客功能的配置主要是在工作文件夹下的_config.yml中配置完成的，里面的每一项都是一个配置，可以自己去查阅资料并付诸实践。 然后我们试着切换网页的顶部标签，首页、归档切换都正常，但是分类、标签、关于在点击后都会跳转异常，出现Cannot GET..的错误，显然这是是路径找不到的原因，我们在工作文件夹下执行： 123hexo new page categorieshexo new page tagshexo new page about 执行了上述3条命令后，工作文件夹下的source文件夹下会生成三个文件夹，如下： 三个文件夹下各自有一个index.md文件，打开后内分别如下： 1234---title: categoriesdate: 2020-04-12 18:20:14--- 1234---title: tagsdate: 2020-04-12 18:20:21--- 1234---title: aboutdate: 2020-04-12 18:23:16--- 接着分别将他们修改成： 1234567---title: 分类date: 2020-04-12 18:20:14type: categorieslayout: categoriescomments: false--- 1234567---title: 标签date: 2020-04-12 18:20:21type: tagslayout: tagscomments: false--- 1234567---title: 关于date: 2020-04-12 18:23:16type: aboutlayout: aboutcomments: false--- 这时候我们再进入网页，就不会有之前的Cannot GET..错误发生啦。 配置站内搜索网页右上角有一个搜索按钮，点击后能显示搜索框，但是不能搜索。这时候还需要使用终端定位到工作文件夹执行如下命令来开启搜索。 1npm install -S hexo-generator-json-content 然后就可以搜索啦。 配置小结通过上述的一系列的配置，本地服务算是基本正常了，还有更多的配置，这里我不再细说了。毕竟相关的配置还是很多的，需要自己一步一步地探索。本人就是在查阅大量网络资料并通过实践来实现整个博客功能的。 编写并发布文章编写第一篇文章终于可以发布文章了，Hexo发布文章是通过Markdown形式来发布的，发布后，Hexo再将Markdown转换成HTML形式显示到网页上。不过这里的Markdown稍微有点点讲究，标题需要用Hexo规定的格式来。我们先来创建一篇文章吧。终端定位到工作文件夹，键入： 1hexo new &quot;第一篇文章&quot; &lt;工作文件夹&gt;/source/_post/路径下会生成第一篇文章.md 我们使用访达找到并打开该文件，内容如下： 12345---title: 你好 Hexodate: 2020-04-12 18:57:32tags:--- 我们可以给这一篇文章添加分类和标签，然后写入正文，编辑内容如下： 12345678910---title: 你好 Hexodate: 2020-04-12 18:57:32categories: - Hexo学习tags:- hexo- 经验--- 在Hexo的Markdown中，上述片段中其实已经包含大标题了，所以我们可以只在在下面写入正文 1234567891011121314151617## 第一章### 1.1 Hello hexo哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈### 1.2 Dear hexo呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵### 1.1 See you again hexo嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿嘿&gt; [单身交友点此处](https://github.com/cba023) 编辑并保存该文件，这样就算写好一篇文章了，可以看出，Hexo发文的标题是由文件内部的标题决定的，与文件名无关 本地服务预览编写的博文这时候不需要发布文章就能在localhost:4000中看到刚才编写的文章了。 点击查看文章内容 是不是一切OK。 发布到线上如果那么精彩的博文只能自己一个人看到，只能说是莫大的遗憾，为了不让遗憾上演，我们接下来把整个文章推送到我们之前配置的GitHub链接。第一次推送需要安装本地依赖，终端定位到工作文件夹执行： 1npm install hexo-deployer-git --save 我们每次发布文章需要向远程把我们的Hexo工作文件夹更改推送过去，执行: 1hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 推送成功后，我们可以访问远程的服务上的文章啦。删除文章同理，删除_post文件夹里的某一篇文章，本地同步到远程就会覆盖远程的服务。 就是这么简单！✌️✌️","categories":[],"tags":[]},{"title":"你好，Hexo","slug":"你好，Hexo","date":"2020-04-10T16:00:00.000Z","updated":"2023-08-08T11:36:05.745Z","comments":true,"path":"posts/8ec25db2/","link":"","permalink":"https://cba023.github.io/posts/8ec25db2/","excerpt":"","text":"我直接拿了Hexo的hello_world文档做了个翻译，就算是我在上面发表的第一篇博文吧！😁😁 官网：https://hexo.io/ 文档：https://hexo.io/docs/ 故障排除：https://hexo.io/docs/troubleshooting.html GitHub issues：https://github.com/hexojs/hexo/issues 快速开始创建新帖1$ hexo new &quot;你好，Hexo&quot; https://hexo.io/docs/writing.html 运行服务1$ hexo server https://hexo.io/docs/server.html 生成静态文件1$ hexo generate https://hexo.io/docs/generating.html 发布到远程站点1$ hexo deploy https://hexo.io/docs/one-command-deployment.html","categories":[{"name":"hexo学习","slug":"hexo学习","permalink":"https://cba023.github.io/categories/hexo%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://cba023.github.io/tags/hexo/"},{"name":"经验","slug":"经验","permalink":"https://cba023.github.io/tags/%E7%BB%8F%E9%AA%8C/"}]}],"categories":[{"name":"hexo学习","slug":"hexo学习","permalink":"https://cba023.github.io/categories/hexo%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://cba023.github.io/tags/hexo/"},{"name":"经验","slug":"经验","permalink":"https://cba023.github.io/tags/%E7%BB%8F%E9%AA%8C/"}]}